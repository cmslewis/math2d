Hello vectormath

<h3 id="ibox" class="vectormath-reference-header">
  IBox
</h3>
<code>IBox</code> –
<h4>Signature</h4>
<p>
  IBox()
</p>
<h4>Description</h4>
<p></p>
<h3 id="iintersection" class="vectormath-reference-header">
  IIntersection
</h3>
<code>IIntersection</code> –
<h4>Signature</h4>
<p>
  IIntersection()
</p>
<h4>Description</h4>
<p></p>
<h3 id="iline" class="vectormath-reference-header">
  ILine
</h3>
<code>ILine</code> –
<h4>Signature</h4>
<p>
  ILine()
</p>
<h4>Description</h4>
<p></p>
<h3 id="imat2x3" class="vectormath-reference-header">
  IMat2x3
</h3>
<code>IMat2x3</code> –
<h4>Signature</h4>
<p>
  IMat2x3()
</p>
<h4>Description</h4>
<p></p>
<h3 id="iray" class="vectormath-reference-header">
  IRay
</h3>
<code>IRay</code> –
<h4>Signature</h4>
<p>
  IRay()
</p>
<h4>Description</h4>
<p></p>
<h3 id="isegment" class="vectormath-reference-header">
  ISegment
</h3>
<code>ISegment</code> –
<h4>Signature</h4>
<p>
  ISegment()
</p>
<h4>Description</h4>
<p></p>
<h3 id="ivec" class="vectormath-reference-header">
  IVec
</h3>
<code>IVec</code> –
<h4>Signature</h4>
<p>
  IVec()
</p>
<h4>Description</h4>
<p></p>
<h3 id="ipolygon" class="vectormath-reference-header">
  IPolygon
</h3>
<code>IPolygon</code> –
<h4>Signature</h4>
<p>
  IPolygon()
</p>
<h4>Description</h4>
<p></p>
<h3 id="ipolyline" class="vectormath-reference-header">
  IPolyline
</h3>
<code>IPolyline</code> –
<h4>Signature</h4>
<p>
  IPolyline()
</p>
<h4>Description</h4>
<p></p>
<h3 id="out_max_x" class="vectormath-reference-header">
  OUT_MAX_X
</h3>
<code>OUT_MAX_X</code> –
<h4>Signature</h4>
<p>
  OUT_MAX_X()
</p>
<h4>Description</h4>
<p></p>
<h3 id="out_max_y" class="vectormath-reference-header">
  OUT_MAX_Y
</h3>
<code>OUT_MAX_Y</code> –
<h4>Signature</h4>
<p>
  OUT_MAX_Y()
</p>
<h4>Description</h4>
<p></p>
<h3 id="out_min_x" class="vectormath-reference-header">
  OUT_MIN_X
</h3>
<code>OUT_MIN_X</code> –
<h4>Signature</h4>
<p>
  OUT_MIN_X()
</p>
<h4>Description</h4>
<p></p>
<h3 id="out_min_y" class="vectormath-reference-header">
  OUT_MIN_Y
</h3>
<code>OUT_MIN_Y</code> –
<h4>Signature</h4>
<p>
  OUT_MIN_Y()
</p>
<h4>Description</h4>
<p></p>
<h3 id="boxalloc" class="vectormath-reference-header">
  boxAlloc
</h3>
<code>boxAlloc</code> –
<h4>Signature</h4>
<p>
  boxAlloc()
</p>
<h4>Description</h4>
<p>Creates a new Box object in memory, with all values initialized to NaN.
This is useful to hold the result of vectormath function calls in performance
critical workflows.</p>
<h3 id="boxclone" class="vectormath-reference-header">
  boxClone
</h3>
<code>boxClone</code> –
    copy the values from the given box into a new box
<h4>Signature</h4>
<p>
  boxClone(box: IBox,out: IBox,)
</p>
<h4>Description</h4>
<p>&#x60;boxClone&#x60; copies values from an existing IBox into a new box or memory location.</p>
<h3 id="boxcomputeoutcode" class="vectormath-reference-header">
  boxComputeOutCode
</h3>
<code>boxComputeOutCode</code> –
<h4>Signature</h4>
<p>
  boxComputeOutCode(box: IBox,point: IVec,)
</p>
<h4>Description</h4>
<p>Determines wehre the specified point lies in respect to the given box. The returned
value is an OR of the possible values OUT_MIN_X, OUT_MAX_X, OUT_MIN_Y, and OUT_MAX_Y
indicating, for each side, whether the point lies beyond that edge.</p>
<h3 id="boxcontainsbox" class="vectormath-reference-header">
  boxContainsBox
</h3>
<code>boxContainsBox</code> –
<h4>Signature</h4>
<p>
  boxContainsBox(a: IBox,b: IBox,)
</p>
<h4>Description</h4>
<p>Determines whether the second box is completely enclosed in the first. Each box is treated
as a closed area, so e.g. the two boxes may share an edge and this method would still return &#x60;true&#x60;.</p>
<h3 id="boxcontainspoint" class="vectormath-reference-header">
  boxContainsPoint
</h3>
<code>boxContainsPoint</code> –
<h4>Signature</h4>
<p>
  boxContainsPoint(box: IBox,point: IVec,)
</p>
<h4>Description</h4>
<p>Determines whether the box contains a given point. The box is treated as a closed area,
so points on the boundary of the box will still return &#x60;true&#x60;.</p>
<h3 id="boxencapsulate" class="vectormath-reference-header">
  boxEncapsulate
</h3>
<code>boxEncapsulate</code> –
<h4>Signature</h4>
<p>
  boxEncapsulate(box: IBox,point: IVec,out: IBox,)
</p>
<h4>Description</h4>
<p>Grows the box to include a given point. If the point is already inside the box, this function
does nothing.</p>
<h3 id="boxintersection" class="vectormath-reference-header">
  boxIntersection
</h3>
<code>boxIntersection</code> –
<h4>Signature</h4>
<p>
  boxIntersection(a: IBox,b: IBox,out: IBox,)
</p>
<h4>Description</h4>
<p>Computes the area intersection of the two box regions, as a box. If the two boxes do not intersect,
the returned value will be an empty box, i.e. with &#x60;maxX &lt; minX&#x60; or &#x60;maxY &lt; minY&#x60;.</p>
<h3 id="boxintersectsbox" class="vectormath-reference-header">
  boxIntersectsBox
</h3>
<code>boxIntersectsBox</code> –
<h4>Signature</h4>
<p>
  boxIntersectsBox(a: IBox,b: IBox,)
</p>
<h4>Description</h4>
<p>Determines whether the two boxes intersect, as areas. Both boxes are treated as closed
regions, so e.g. this function will return &#x60;true&#x60; if the boxes share only a single edge.</p>
<h3 id="boxisempty" class="vectormath-reference-header">
  boxIsEmpty
</h3>
<code>boxIsEmpty</code> –
<h4>Signature</h4>
<p>
  boxIsEmpty(box: IBox,)
</p>
<h4>Description</h4>
<p>Determines whether this box represents an empty area. A box is considered empty if
its &#x60;maxX &lt; minX&#x60; or its &#x60;maxY &lt; minY&#x60;.</p>
<h3 id="boxreset" class="vectormath-reference-header">
  boxReset
</h3>
<code>boxReset</code> –
<h4>Signature</h4>
<p>
  boxReset(minX: number,minY: number,maxX: number,maxY: number,out: IBox,)
</p>
<h4>Description</h4>
<p>Constuct a new box given &#x60;minX&#x60;, &#x60;minY&#x60;, &#x60;maxX&#x60;, and &#x60;maxY&#x60; bounding values.</p>
<h3 id="boxtransformbyaff" class="vectormath-reference-header">
  boxTransformByAff
</h3>
<code>boxTransformByAff</code> –
<h4>Signature</h4>
<p>
  boxTransformByAff(box: IBox,mat: IMat2x3,out: IBox,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="boxunion" class="vectormath-reference-header">
  boxUnion
</h3>
<code>boxUnion</code> –
<h4>Signature</h4>
<p>
  boxUnion(a: IBox,b: IBox,out: IBox,)
</p>
<h4>Description</h4>
<p>Compute the smallest bounding box that contains both given boxes.</p>
<h3 id="intersectionalloc" class="vectormath-reference-header">
  intersectionAlloc
</h3>
<code>intersectionAlloc</code> –
<h4>Signature</h4>
<p>
  intersectionAlloc()
</p>
<h4>Description</h4>
<p>Creates a new Intersection object in memory, with all values initialized to &#x60;false&#x60; and &#x60;NaN&#x60;.
This is useful to hold the result of vectormath function calls in performance
critical workflows.</p>
<h3 id="intersectionclone" class="vectormath-reference-header">
  intersectionClone
</h3>
<code>intersectionClone</code> –
<h4>Signature</h4>
<p>
  intersectionClone(intersection: IIntersection,out: IIntersection,)
</p>
<h4>Description</h4>
<p>Copies the values from the given intersection into a new intersection object.</p>
<h3 id="intersectionreset" class="vectormath-reference-header">
  intersectionReset
</h3>
<code>intersectionReset</code> –
<h4>Signature</h4>
<p>
  intersectionReset(exists: boolean,x: number,y: number,t0: number,t1: number,out: IIntersection,)
</p>
<h4>Description</h4>
<p>Constuct a new intersection given &#x60;exists&#x60;, &#x60;x&#x60;, &#x60;y&#x60;, &#x60;t0&#x60;, and &#x60;t1&#x60; values.</p>
<h3 id="linealloc" class="vectormath-reference-header">
  lineAlloc
</h3>
<code>lineAlloc</code> –
<h4>Signature</h4>
<p>
  lineAlloc()
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineclone" class="vectormath-reference-header">
  lineClone
</h3>
<code>lineClone</code> –
<h4>Signature</h4>
<p>
  lineClone(line: ILine,out: ILine,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineclosestdistancetopoint" class="vectormath-reference-header">
  lineClosestDistanceToPoint
</h3>
<code>lineClosestDistanceToPoint</code> –
<h4>Signature</h4>
<p>
  lineClosestDistanceToPoint(line: ILine,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineclosestsigneddistancetopoint" class="vectormath-reference-header">
  lineClosestSignedDistanceToPoint
</h3>
<code>lineClosestSignedDistanceToPoint</code> –
<h4>Signature</h4>
<p>
  lineClosestSignedDistanceToPoint(line: ILine,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="linecontainspoint" class="vectormath-reference-header">
  lineContainsPoint
</h3>
<code>lineContainsPoint</code> –
<h4>Signature</h4>
<p>
  lineContainsPoint(line: ILine,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineintersectline" class="vectormath-reference-header">
  lineIntersectLine
</h3>
<code>lineIntersectLine</code> –
<h4>Signature</h4>
<p>
  lineIntersectLine(a: ILine,b: ILine,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineintersectpolylineiterator" class="vectormath-reference-header">
  lineIntersectPolylineIterator
</h3>
<code>lineIntersectPolylineIterator</code> –
<h4>Signature</h4>
<p>
  lineIntersectPolylineIterator(line: ILine,poly: IPolyline,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineintersectray" class="vectormath-reference-header">
  lineIntersectRay
</h3>
<code>lineIntersectRay</code> –
<h4>Signature</h4>
<p>
  lineIntersectRay(line: ILine,ray: IRay,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineintersectsegment" class="vectormath-reference-header">
  lineIntersectSegment
</h3>
<code>lineIntersectSegment</code> –
<h4>Signature</h4>
<p>
  lineIntersectSegment(line: ILine,segment: ISegment,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="linelookat" class="vectormath-reference-header">
  lineLookAt
</h3>
<code>lineLookAt</code> –
<h4>Signature</h4>
<p>
  lineLookAt(from: IVec,to: IVec,out: ILine,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="linepointat" class="vectormath-reference-header">
  linePointAt
</h3>
<code>linePointAt</code> –
<h4>Signature</h4>
<p>
  linePointAt(line: ILine,t: number,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineprojectpoint" class="vectormath-reference-header">
  lineProjectPoint
</h3>
<code>lineProjectPoint</code> –
<h4>Signature</h4>
<p>
  lineProjectPoint(line: ILine,point: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="linereset" class="vectormath-reference-header">
  lineReset
</h3>
<code>lineReset</code> –
<h4>Signature</h4>
<p>
  lineReset(x0: number,y0: number,dirX: number,dirY: number,out: ILine,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="lineside" class="vectormath-reference-header">
  lineSide
</h3>
<code>lineSide</code> –
<h4>Signature</h4>
<p>
  lineSide(line: ILine,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="linetransformbyaff" class="vectormath-reference-header">
  lineTransformByAff
</h3>
<code>lineTransformByAff</code> –
<h4>Signature</h4>
<p>
  lineTransformByAff(line: ILine,mat: IMat2x3,out: ILine,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3affdeterminant" class="vectormath-reference-header">
  mat2x3AffDeterminant
</h3>
<code>mat2x3AffDeterminant</code> –
<h4>Signature</h4>
<p>
  mat2x3AffDeterminant(mat: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3afffromrotation" class="vectormath-reference-header">
  mat2x3AffFromRotation
</h3>
<code>mat2x3AffFromRotation</code> –
<h4>Signature</h4>
<p>
  mat2x3AffFromRotation(theta: number,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3afffromtranslation" class="vectormath-reference-header">
  mat2x3AffFromTranslation
</h3>
<code>mat2x3AffFromTranslation</code> –
<h4>Signature</h4>
<p>
  mat2x3AffFromTranslation(tx: number,ty: number,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3affidentity" class="vectormath-reference-header">
  mat2x3AffIdentity
</h3>
<code>mat2x3AffIdentity</code> –
<h4>Signature</h4>
<p>
  mat2x3AffIdentity(out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3affinvert" class="vectormath-reference-header">
  mat2x3AffInvert
</h3>
<code>mat2x3AffInvert</code> –
<h4>Signature</h4>
<p>
  mat2x3AffInvert(mat: IMat2x3,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3affisorthogonal" class="vectormath-reference-header">
  mat2x3AffIsOrthogonal
</h3>
<code>mat2x3AffIsOrthogonal</code> –
<h4>Signature</h4>
<p>
  mat2x3AffIsOrthogonal(mat: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3affistranslationonly" class="vectormath-reference-header">
  mat2x3AffIsTranslationOnly
</h3>
<code>mat2x3AffIsTranslationOnly</code> –
<h4>Signature</h4>
<p>
  mat2x3AffIsTranslationOnly(mat: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3affmulmat2x3" class="vectormath-reference-header">
  mat2x3AffMulMat2x3
</h3>
<code>mat2x3AffMulMat2x3</code> –
<h4>Signature</h4>
<p>
  mat2x3AffMulMat2x3(m1: IMat2x3,m2: IMat2x3,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3affrotate" class="vectormath-reference-header">
  mat2x3AffRotate
</h3>
<code>mat2x3AffRotate</code> –
<h4>Signature</h4>
<p>
  mat2x3AffRotate(mat: IMat2x3,theta: number,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3affscale" class="vectormath-reference-header">
  mat2x3AffScale
</h3>
<code>mat2x3AffScale</code> –
<h4>Signature</h4>
<p>
  mat2x3AffScale(mat: IMat2x3,scalar: number,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3afftranslate" class="vectormath-reference-header">
  mat2x3AffTranslate
</h3>
<code>mat2x3AffTranslate</code> –
<h4>Signature</h4>
<p>
  mat2x3AffTranslate(mat: IMat2x3,tx: number,ty: number,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3alloc" class="vectormath-reference-header">
  mat2x3Alloc
</h3>
<code>mat2x3Alloc</code> –
<h4>Signature</h4>
<p>
  mat2x3Alloc()
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3clone" class="vectormath-reference-header">
  mat2x3Clone
</h3>
<code>mat2x3Clone</code> –
<h4>Signature</h4>
<p>
  mat2x3Clone(mat: IMat2x3,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="mat2x3reset" class="vectormath-reference-header">
  mat2x3Reset
</h3>
<code>mat2x3Reset</code> –
<h4>Signature</h4>
<p>
  mat2x3Reset(a: number,b: number,c: number,d: number,e: number,f: number,out: IMat2x3,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonalloc" class="vectormath-reference-header">
  polygonAlloc
</h3>
<code>polygonAlloc</code> –
<h4>Signature</h4>
<p>
  polygonAlloc()
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygoncontainspoint" class="vectormath-reference-header">
  polygonContainsPoint
</h3>
<code>polygonContainsPoint</code> –
<h4>Signature</h4>
<p>
  polygonContainsPoint(poly: IPolygon,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygongetbounds" class="vectormath-reference-header">
  polygonGetBounds
</h3>
<code>polygonGetBounds</code> –
<h4>Signature</h4>
<p>
  polygonGetBounds(poly: IPolygon,out: IBox,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygongetnumsides" class="vectormath-reference-header">
  polygonGetNumSides
</h3>
<code>polygonGetNumSides</code> –
<h4>Signature</h4>
<p>
  polygonGetNumSides(poly: IPolygon,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygongetperimeter" class="vectormath-reference-header">
  polygonGetPerimeter
</h3>
<code>polygonGetPerimeter</code> –
<h4>Signature</h4>
<p>
  polygonGetPerimeter(poly: IPolygon,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygongetsidelength" class="vectormath-reference-header">
  polygonGetSideLength
</h3>
<code>polygonGetSideLength</code> –
<h4>Signature</h4>
<p>
  polygonGetSideLength(poly: IPolygon,idx: number,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygongetsidesegment" class="vectormath-reference-header">
  polygonGetSideSegment
</h3>
<code>polygonGetSideSegment</code> –
<h4>Signature</h4>
<p>
  polygonGetSideSegment(poly: IPolygon,index: number,out: ISegment,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonintersectlineiterator" class="vectormath-reference-header">
  polygonIntersectLineIterator
</h3>
<code>polygonIntersectLineIterator</code> –
<h4>Signature</h4>
<p>
  polygonIntersectLineIterator(poly: IPolygon,line: ILine,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonintersectrayiterator" class="vectormath-reference-header">
  polygonIntersectRayIterator
</h3>
<code>polygonIntersectRayIterator</code> –
<h4>Signature</h4>
<p>
  polygonIntersectRayIterator(poly: IPolygon,ray: IRay,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonintersectsegmentiterator" class="vectormath-reference-header">
  polygonIntersectSegmentIterator
</h3>
<code>polygonIntersectSegmentIterator</code> –
<h4>Signature</h4>
<p>
  polygonIntersectSegmentIterator(poly: IPolygon,segment: ISegment,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonnearestpoint" class="vectormath-reference-header">
  polygonNearestPoint
</h3>
<code>polygonNearestPoint</code> –
<h4>Signature</h4>
<p>
  polygonNearestPoint(poly: IPolygon,point: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonnearestt" class="vectormath-reference-header">
  polygonNearestT
</h3>
<code>polygonNearestT</code> –
<h4>Signature</h4>
<p>
  polygonNearestT(poly: IPolygon,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonnearestvertexindex" class="vectormath-reference-header">
  polygonNearestVertexIndex
</h3>
<code>polygonNearestVertexIndex</code> –
<h4>Signature</h4>
<p>
  polygonNearestVertexIndex(poly: IPolygon,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonpointat" class="vectormath-reference-header">
  polygonPointAt
</h3>
<code>polygonPointAt</code> –
<h4>Signature</h4>
<p>
  polygonPointAt(poly: IPolygon,t: number,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygonsideindexat" class="vectormath-reference-header">
  polygonSideIndexAt
</h3>
<code>polygonSideIndexAt</code> –
<h4>Signature</h4>
<p>
  polygonSideIndexAt(poly: IPolygon,t: number,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polygontransformbyaff" class="vectormath-reference-header">
  polygonTransformByAff
</h3>
<code>polygonTransformByAff</code> –
<h4>Signature</h4>
<p>
  polygonTransformByAff(poly: IPolygon,mat: IMat2x3,out: ,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinealloc" class="vectormath-reference-header">
  polylineAlloc
</h3>
<code>polylineAlloc</code> –
<h4>Signature</h4>
<p>
  polylineAlloc()
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylineclose" class="vectormath-reference-header">
  polylineClose
</h3>
<code>polylineClose</code> –
<h4>Signature</h4>
<p>
  polylineClose(poly: IPolyline,out: ,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinegetbounds" class="vectormath-reference-header">
  polylineGetBounds
</h3>
<code>polylineGetBounds</code> –
<h4>Signature</h4>
<p>
  polylineGetBounds(poly: IPolyline,out: IBox,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinegetlength" class="vectormath-reference-header">
  polylineGetLength
</h3>
<code>polylineGetLength</code> –
<h4>Signature</h4>
<p>
  polylineGetLength(poly: IPolyline,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinegetnumsegments" class="vectormath-reference-header">
  polylineGetNumSegments
</h3>
<code>polylineGetNumSegments</code> –
<h4>Signature</h4>
<p>
  polylineGetNumSegments(poly: IPolyline,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinegetsegment" class="vectormath-reference-header">
  polylineGetSegment
</h3>
<code>polylineGetSegment</code> –
<h4>Signature</h4>
<p>
  polylineGetSegment(poly: IPolyline,index: number,out: ISegment,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinegetsegmentlength" class="vectormath-reference-header">
  polylineGetSegmentLength
</h3>
<code>polylineGetSegmentLength</code> –
<h4>Signature</h4>
<p>
  polylineGetSegmentLength(poly: IPolyline,idx: number,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinegetvertex" class="vectormath-reference-header">
  polylineGetVertex
</h3>
<code>polylineGetVertex</code> –
<h4>Signature</h4>
<p>
  polylineGetVertex(poly: IPolyline,index: number,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylineintersectlineiterator" class="vectormath-reference-header">
  polylineIntersectLineIterator
</h3>
<code>polylineIntersectLineIterator</code> –
<h4>Signature</h4>
<p>
  polylineIntersectLineIterator(poly: IPolyline,line: ILine,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylineintersectrayiterator" class="vectormath-reference-header">
  polylineIntersectRayIterator
</h3>
<code>polylineIntersectRayIterator</code> –
<h4>Signature</h4>
<p>
  polylineIntersectRayIterator(poly: IPolyline,ray: IRay,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylineintersectsegmentiterator" class="vectormath-reference-header">
  polylineIntersectSegmentIterator
</h3>
<code>polylineIntersectSegmentIterator</code> –
<h4>Signature</h4>
<p>
  polylineIntersectSegmentIterator(poly: IPolyline,segment: ISegment,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylineisclosed" class="vectormath-reference-header">
  polylineIsClosed
</h3>
<code>polylineIsClosed</code> –
<h4>Signature</h4>
<p>
  polylineIsClosed(poly: IPolyline,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinenearestpoint" class="vectormath-reference-header">
  polylineNearestPoint
</h3>
<code>polylineNearestPoint</code> –
<h4>Signature</h4>
<p>
  polylineNearestPoint(poly: IPolyline,point: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinenearestt" class="vectormath-reference-header">
  polylineNearestT
</h3>
<code>polylineNearestT</code> –
<h4>Signature</h4>
<p>
  polylineNearestT(poly: IPolyline,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinenearestvertexindex" class="vectormath-reference-header">
  polylineNearestVertexIndex
</h3>
<code>polylineNearestVertexIndex</code> –
<h4>Signature</h4>
<p>
  polylineNearestVertexIndex(poly: IPolyline,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinepointat" class="vectormath-reference-header">
  polylinePointAt
</h3>
<code>polylinePointAt</code> –
<h4>Signature</h4>
<p>
  polylinePointAt(poly: IPolyline,d: number,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinesegmentindexat" class="vectormath-reference-header">
  polylineSegmentIndexAt
</h3>
<code>polylineSegmentIndexAt</code> –
<h4>Signature</h4>
<p>
  polylineSegmentIndexAt(poly: IPolyline,d: number,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinetransformbyaff" class="vectormath-reference-header">
  polylineTransformByAff
</h3>
<code>polylineTransformByAff</code> –
<h4>Signature</h4>
<p>
  polylineTransformByAff(poly: IPolyline,mat: IMat2x3,out: ,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="polylinetrim" class="vectormath-reference-header">
  polylineTrim
</h3>
<code>polylineTrim</code> –
<h4>Signature</h4>
<p>
  polylineTrim(poly: IPolyline,begin: number,end: number,out: ,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="rayalloc" class="vectormath-reference-header">
  rayAlloc
</h3>
<code>rayAlloc</code> –
<h4>Signature</h4>
<p>
  rayAlloc()
</p>
<h4>Description</h4>
<p></p>
<h3 id="rayclone" class="vectormath-reference-header">
  rayClone
</h3>
<code>rayClone</code> –
<h4>Signature</h4>
<p>
  rayClone(ray: IRay,out: IRay,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="raycontainspoint" class="vectormath-reference-header">
  rayContainsPoint
</h3>
<code>rayContainsPoint</code> –
<h4>Signature</h4>
<p>
  rayContainsPoint(ray: IRay,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="raygetclosestdistancetopoint" class="vectormath-reference-header">
  rayGetClosestDistanceToPoint
</h3>
<code>rayGetClosestDistanceToPoint</code> –
<h4>Signature</h4>
<p>
  rayGetClosestDistanceToPoint(ray: IRay,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="raygetclosestpoint" class="vectormath-reference-header">
  rayGetClosestPoint
</h3>
<code>rayGetClosestPoint</code> –
<h4>Signature</h4>
<p>
  rayGetClosestPoint(ray: IRay,point: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="rayintersectline" class="vectormath-reference-header">
  rayIntersectLine
</h3>
<code>rayIntersectLine</code> –
<h4>Signature</h4>
<p>
  rayIntersectLine(ray: IRay,line: ILine,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="rayintersectpolylineiterator" class="vectormath-reference-header">
  rayIntersectPolylineIterator
</h3>
<code>rayIntersectPolylineIterator</code> –
<h4>Signature</h4>
<p>
  rayIntersectPolylineIterator(ray: IRay,poly: IPolyline,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="rayintersectray" class="vectormath-reference-header">
  rayIntersectRay
</h3>
<code>rayIntersectRay</code> –
<h4>Signature</h4>
<p>
  rayIntersectRay(a: IRay,b: IRay,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="rayintersectsegment" class="vectormath-reference-header">
  rayIntersectSegment
</h3>
<code>rayIntersectSegment</code> –
<h4>Signature</h4>
<p>
  rayIntersectSegment(ray: IRay,segment: ISegment,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="raylookat" class="vectormath-reference-header">
  rayLookAt
</h3>
<code>rayLookAt</code> –
<h4>Signature</h4>
<p>
  rayLookAt(from: IVec,to: IVec,out: IRay,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="raypointat" class="vectormath-reference-header">
  rayPointAt
</h3>
<code>rayPointAt</code> –
<h4>Signature</h4>
<p>
  rayPointAt(ray: IRay,t: number,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="rayreset" class="vectormath-reference-header">
  rayReset
</h3>
<code>rayReset</code> –
<h4>Signature</h4>
<p>
  rayReset(x0: number,y0: number,dirX: number,dirY: number,out: IRay,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="raytransformbyaff" class="vectormath-reference-header">
  rayTransformByAff
</h3>
<code>rayTransformByAff</code> –
<h4>Signature</h4>
<p>
  rayTransformByAff(ray: IRay,mat: IMat2x3,out: IRay,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentalloc" class="vectormath-reference-header">
  segmentAlloc
</h3>
<code>segmentAlloc</code> –
<h4>Signature</h4>
<p>
  segmentAlloc()
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentgetendpoint0" class="vectormath-reference-header">
  segmentGetEndpoint0
</h3>
<code>segmentGetEndpoint0</code> –
<h4>Signature</h4>
<p>
  segmentGetEndpoint0(segment: ISegment,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentgetendpoint1" class="vectormath-reference-header">
  segmentGetEndpoint1
</h3>
<code>segmentGetEndpoint1</code> –
<h4>Signature</h4>
<p>
  segmentGetEndpoint1(segment: ISegment,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentgetlength" class="vectormath-reference-header">
  segmentGetLength
</h3>
<code>segmentGetLength</code> –
<h4>Signature</h4>
<p>
  segmentGetLength(segment: ISegment,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentgetlengthsq" class="vectormath-reference-header">
  segmentGetLengthSq
</h3>
<code>segmentGetLengthSq</code> –
<h4>Signature</h4>
<p>
  segmentGetLengthSq(segment: ISegment,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentintersectline" class="vectormath-reference-header">
  segmentIntersectLine
</h3>
<code>segmentIntersectLine</code> –
<h4>Signature</h4>
<p>
  segmentIntersectLine(segment: ISegment,line: ILine,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentintersectpolylineiterator" class="vectormath-reference-header">
  segmentIntersectPolylineIterator
</h3>
<code>segmentIntersectPolylineIterator</code> –
<h4>Signature</h4>
<p>
  segmentIntersectPolylineIterator(segment: ISegment,poly: IPolyline,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentintersectray" class="vectormath-reference-header">
  segmentIntersectRay
</h3>
<code>segmentIntersectRay</code> –
<h4>Signature</h4>
<p>
  segmentIntersectRay(segment: ISegment,ray: IRay,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentintersectsegment" class="vectormath-reference-header">
  segmentIntersectSegment
</h3>
<code>segmentIntersectSegment</code> –
<h4>Signature</h4>
<p>
  segmentIntersectSegment(a: ISegment,b: ISegment,out: IIntersection,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentnearestpoint" class="vectormath-reference-header">
  segmentNearestPoint
</h3>
<code>segmentNearestPoint</code> –
<h4>Signature</h4>
<p>
  segmentNearestPoint(segment: ISegment,point: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentnearestt" class="vectormath-reference-header">
  segmentNearestT
</h3>
<code>segmentNearestT</code> –
<h4>Signature</h4>
<p>
  segmentNearestT(segment: ISegment,point: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentpointat" class="vectormath-reference-header">
  segmentPointAt
</h3>
<code>segmentPointAt</code> –
<h4>Signature</h4>
<p>
  segmentPointAt(segment: ISegment,t: number,out: IVec,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentreset" class="vectormath-reference-header">
  segmentReset
</h3>
<code>segmentReset</code> –
<h4>Signature</h4>
<p>
  segmentReset(x0: number,y0: number,x1: number,y1: number,out: ISegment,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="segmentreverse" class="vectormath-reference-header">
  segmentReverse
</h3>
<code>segmentReverse</code> –
<h4>Signature</h4>
<p>
  segmentReverse(segment: ISegment,out: ISegment,)
</p>
<h4>Description</h4>
<p></p>
<h3 id="vecadd" class="vectormath-reference-header">
  vecAdd
</h3>
<code>vecAdd</code> –
<h4>Signature</h4>
<p>
  vecAdd(a: IVec,b: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p>Computes the result of adding the two given vectors.</p>
<h3 id="vecalloc" class="vectormath-reference-header">
  vecAlloc
</h3>
<code>vecAlloc</code> –
<h4>Signature</h4>
<p>
  vecAlloc()
</p>
<h4>Description</h4>
<p>Creates a new Vec object in memory, with all values initialized to NaN.
This is useful to hold the result of vectormath function calls in performance
critical workflows.</p>
<h3 id="vecclone" class="vectormath-reference-header">
  vecClone
</h3>
<code>vecClone</code> –
<h4>Signature</h4>
<p>
  vecClone(vec: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p>Copies the values from the given vector into a new vector.</p>
<h3 id="vecdistance" class="vectormath-reference-header">
  vecDistance
</h3>
<code>vecDistance</code> –
<h4>Signature</h4>
<p>
  vecDistance(a: IVec,b: IVec,)
</p>
<h4>Description</h4>
<p>Computes the straight-line (Euclidean) distance between the two vectors, interpreted as points in the plane.</p>
<h3 id="vecdistancesq" class="vectormath-reference-header">
  vecDistanceSq
</h3>
<code>vecDistanceSq</code> –
<h4>Signature</h4>
<p>
  vecDistanceSq(a: IVec,b: IVec,)
</p>
<h4>Description</h4>
<p>Computes the squared straight-line (i.e. Euclidean) distance between the two vectors, interpreted as points in the plane.</p>
<h3 id="vecdot" class="vectormath-reference-header">
  vecDot
</h3>
<code>vecDot</code> –
<h4>Signature</h4>
<p>
  vecDot(a: IVec,b: IVec,)
</p>
<h4>Description</h4>
<p>Computes the dot product of the two vectors, i.e. &#x60;a.x * b.x + a.y * b.y&#x60;.</p>
<h3 id="vecgetlength" class="vectormath-reference-header">
  vecGetLength
</h3>
<code>vecGetLength</code> –
<h4>Signature</h4>
<p>
  vecGetLength(vec: IVec,)
</p>
<h4>Description</h4>
<p>Computes the straight-line length (i.e. Euclidean norm) of the given vector.</p>
<h3 id="vecgetlengthsq" class="vectormath-reference-header">
  vecGetLengthSq
</h3>
<code>vecGetLengthSq</code> –
<h4>Signature</h4>
<p>
  vecGetLengthSq(vec: IVec,)
</p>
<h4>Description</h4>
<p>Computes the squared straight-line length (i.e. square of the Euclidean norm) of the given vector.</p>
<h3 id="vecgetmanhattanlength" class="vectormath-reference-header">
  vecGetManhattanLength
</h3>
<code>vecGetManhattanLength</code> –
<h4>Signature</h4>
<p>
  vecGetManhattanLength(vec: IVec,)
</p>
<h4>Description</h4>
<p>Computes the Manhattan length of the given vector, i.e. &#x60;|x| + |y|&#x60;.</p>
<h3 id="veclerp" class="vectormath-reference-header">
  vecLerp
</h3>
<code>vecLerp</code> –
<h4>Signature</h4>
<p>
  vecLerp(a: IVec,b: IVec,r: number,out: IVec,)
</p>
<h4>Description</h4>
<p>Performs a linear interpolation between the two vectors. The &#x60;r&#x60; parameter is allowed to be outside &#x60;[0, 1]&#x60;.</p>
<h3 id="vecmanhattandistance" class="vectormath-reference-header">
  vecManhattanDistance
</h3>
<code>vecManhattanDistance</code> –
<h4>Signature</h4>
<p>
  vecManhattanDistance(a: IVec,b: IVec,)
</p>
<h4>Description</h4>
<p>Computes the Manhattan distance between the two vectors, interpreted as points in the plane.
Equivalent to &#x60;|b.x - a.x| + |b.y - a.y|&#x60;.</p>
<h3 id="vecnormalize" class="vectormath-reference-header">
  vecNormalize
</h3>
<code>vecNormalize</code> –
<h4>Signature</h4>
<p>
  vecNormalize(vec: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p>Normalizes the vector to be length 1. If the given vector is the zero-vector, this method
returns &#x60;(NaN, NaN)&#x60;.</p>
<h3 id="vecorigin" class="vectormath-reference-header">
  vecOrigin
</h3>
<code>vecOrigin</code> –
<h4>Signature</h4>
<p>
  vecOrigin(out: IVec,)
</p>
<h4>Description</h4>
<p>Returns the 2d origin vector, &#x60;(0, 0)&#x60;.</p>
<h3 id="vecperp" class="vectormath-reference-header">
  vecPerp
</h3>
<code>vecPerp</code> –
<h4>Signature</h4>
<p>
  vecPerp(vec: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p>Computes the perp of the given vector, as defined by &#x60;vecPerp(a, b) &#x3D; (-b, a)&#x60;.
This is equivalent to a counter-clockwise rotation in the standard plane.</p>
<h3 id="vecreset" class="vectormath-reference-header">
  vecReset
</h3>
<code>vecReset</code> –
<h4>Signature</h4>
<p>
  vecReset(x: number,y: number,out: IVec,)
</p>
<h4>Description</h4>
<p>Constuct a new vector given an &#x60;x&#x60; and &#x60;y&#x60; value.</p>
<h3 id="vecscale" class="vectormath-reference-header">
  vecScale
</h3>
<code>vecScale</code> –
<h4>Signature</h4>
<p>
  vecScale(vec: IVec,scalar: number,out: IVec,)
</p>
<h4>Description</h4>
<p>Scales both coordinates of this vector by the given scalar.</p>
<h3 id="vecsubtract" class="vectormath-reference-header">
  vecSubtract
</h3>
<code>vecSubtract</code> –
<h4>Signature</h4>
<p>
  vecSubtract(a: IVec,b: IVec,out: IVec,)
</p>
<h4>Description</h4>
<p>Subrtacts vector &#x60;b&#x60; from vector &#x60;a&#x60;.</p>
<h3 id="vectransformbyaff" class="vectormath-reference-header">
  vecTransformByAff
</h3>
<code>vecTransformByAff</code> –
<h4>Signature</h4>
<p>
  vecTransformByAff(vec: IVec,mat: IMat2x3,out: IVec,)
</p>
<h4>Description</h4>
<p>Multiplies the vector by the given affine matrix.</p>
